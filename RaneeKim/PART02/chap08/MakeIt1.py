# 첫번째 생각은 -1, /5, /3, /2 를 모두 사용해서 연산된 갯수를 count하고 그 중에 제일 작은 count 수를 뽑는 걸 생각함
# Ex) n=9 이면, (/3)(/3), (-1)(/2)(/2)(/2), (-1)(-1)(-1)(-1)(/5) 이렇게 세 방법중 연산 count수가 제일 적은 2가 정답으로 출력될수 있도록
# 코드짜기는 쉽겠지만 숫자가 클 수록 연산 시간이 오래걸릴것같음 -> 책공부 

n = int(input())
f = [0]* (n+1) # 밑에 for문이 돌아가면서 각 숫자마다 min count 수를 저장해주기 위해 리스트 생성
                # n+1인 이유 : 10을 예를들면 실제 값을 구하고 싶은건 f[10] -> 리스트상으로는 11번째 데이터 이므로 11개의 리스트가 필요함
                
for i in range(2, n+1) : # 2 ~ 11 -> 리스트로는 f[2]~f[11] -> 세번째데이터 ~ 10번째데이터

    f[i] = 1 + f[i-1]

    if i%2 == 0 :
        count = 1 + f[i//2] # / 가 아닌  // 이유 : / 하면 나누어떨어지더라도 답은 소수점형태로 출력되므로 정수형태의 답을 받기위해
        f[i] = min(f[i], count)
    
    if i%3 == 0 :
        count = 1 + f[i//3]
        f[i] = min(f[i], count)

    if i%5 == 0 :
         count = 1 + f[i//5]
         f[i] = min(f[i], count)

    print(f[i])

print(f[n])
